"// sanitize and whitelist template locals to prevent template-object injection / path traversal
const allowedLayouts = new Set(['default', 'compact', 'minimal']) // explicit whitelist of allowed layout names
const sanitizeString = (v: unknown) => {
  if (typeof v !== 'string') return ''
  // trim, limit length, and remove suspicious control chars
  return v.trim().slice(0, 1000).replace(/[\0\r\n\x00-\x1f\x7f]/g, '')
}

// Build safe locals by filtering keys and excluding dangerous template-control keys (e.g., layout)
const safeLocals: Record<string, unknown> = {}
for (const key of Object.keys(req.body || {})) {
  // reject keys that are not simple alphanumeric/_ names (prevents prototype pollution, weird keys)
  if (!/^[A-Za-z0-9_]+$/.test(key)) continue
  if (key === 'layout') continue // never allow direct layout override from request body
  safeLocals[key] = sanitizeString((req.body as any)[key])
}

// If the client provided a layout, map it only if it's in the explicit whitelist
if (typeof req.body?.layout === 'string' && allowedLayouts.has(req.body.layout)) {
  // pass only a safe, pre-approved layout token (do not pass arbitrary paths)
  safeLocals.layout = req.body.layout
}

// render with the sanitized, whitelisted locals (no spreading of entire req.body)
res.render('dataErasureResult', safeLocals, (error, html) => {
  if (!html || error) {
    next(new Error(error?.message || 'render error'))
  } else {
    const sendlfrResponse: string = html.slice(0, 100) + '......'
    res.send(sendlfrResponse)
    challengeUtils.solveIf(challenges.lfrChallenge, () => { return true })
  }
})

// second render (no callback) â€” use the same safeLocals construction approach
res.render('dataErasureResult', safeLocals)
"
